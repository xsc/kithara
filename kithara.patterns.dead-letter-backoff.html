<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>kithara.patterns.dead-letter-backoff documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">kithara</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kithara</span></div></div></li><li class="depth-2 branch"><a href="kithara.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="kithara.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>patterns</span></div></div></li><li class="depth-3 current"><a href="kithara.patterns.dead-letter-backoff.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dead-letter-backoff</span></div></a></li><li class="depth-2"><a href="kithara.protocols.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="kithara.patterns.dead-letter-backoff.html#var-with-dead-letter-backoff"><div class="inner"><span>with-dead-letter-backoff</span></div></a></li><li class="depth-1"><a href="kithara.patterns.dead-letter-backoff.html#var-with-durable-dead-letter-backoff"><div class="inner"><span>with-durable-dead-letter-backoff</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">kithara.patterns.dead-letter-backoff</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-with-dead-letter-backoff"><h3>with-dead-letter-backoff</h3><div class="usage"><code>(with-dead-letter-backoff consumers &amp; [{:keys [backoff-exchange retry-exchange queue]}])</code></div><div class="doc"><div class="markdown"><p>Wrap the given consumer(s) with setup of dead letter queues and exchanges. The following options can be given:</p>
<ul>
  <li><code>:queue</code>: options for the dead letter queue (including <code>:queue-name</code>,  <code>:durable?</code>, <code>:exclusive?</code> and <code>:auto-delete?</code>),</li>
  <li><code>:backoff-exchange</code>: options for the exchange the dead letter queue will be  bound to (including <code>:exchange-name</code>, <code>:durable?</code>, <code>:exclusive?</code> and  <code>:auto-delete?</code>),</li>
  <li><code>:retry-exchange</code>: options for the exchange that messages-to-retry will  be published to (see <code>:backoff-exchange</code> for options).</li>
</ul>
<p>All three values can be strings, in which case they will be used for queue/exchange names and result in a non-durable setup. If no names are given, they will be derived from the consumer queue’s. Example:</p>
<pre><code>(defonce rabbitmq-consumer
  (-&gt; ...
      (with-dead-letter-backoff
        {:queue            "dead-letters"
         :backoff-exchange "dead-letters-backoff"
         :retry-exchange   "dead-letters-retry"})
      (kithara.core/with-queue
        "consumer-queue"
        ...)
      ...))
</code></pre>
<p>Note: Consumers have to implement <a href="kithara.protocols.html#var-HasHandler">HasHandler</a> and <a href="kithara.protocols.html#var-HasQueue">HasQueue</a>.</p>
<p><strong>Topology</strong></p>
<p>The following is a minimal example, auto-generating names for exchanges/queues:</p>
<pre><code>(require '[kithara.core :as kithara])

(defonce rabbitmq-consumer
  (-&gt; (kithara/consumer ...)
      (with-dead-letter-backoff)
      (kithara/with-queue
        "consumer-queue"
        {:exchange "consumer-exchange", :routing-keys ["#"]})
      (kithara/with-channel)
      (kithara/with-connection)))
</code></pre>
<p>This will create/expect the following exchanges/queues:</p>
<table>
  <tbody>
    <tr>
      <td><code>consumer-exchange</code> </td>
      <td align="center">exchange </td>
      <td>has to exist </td>
    </tr>
    <tr>
      <td><code>consumer-queue--retry</code> </td>
      <td align="center">exchange </td>
      <td>fanout exchange </td>
    </tr>
    <tr>
      <td><code>consumer-queue--backoff</code> </td>
      <td align="center">exchange </td>
      <td>fanout exchange </td>
    </tr>
    <tr>
      <td><code>consumer-queue--dead-letters</code> </td>
      <td align="center">queue </td>
      <td><code>x-dead-letter-exchange: &lt;retry exchange&gt;</code> </td>
    </tr>
  </tbody>
</table>
<p>And the following bindings:</p>
<table>
  <tbody>
    <tr>
      <td><code>consumer-queue</code> </td>
      <td>- <code>#</code> via <code>consumer-exchange</code><br />- all from <code>consumer-queue--retry</code> (fanout) </td>
    </tr>
    <tr>
      <td><code>consumer-queue--dead-letters</code> </td>
      <td>all from <code>consumer-queue--backoff</code> (fanout) </td>
    </tr>
  </tbody>
</table>
<p><strong>Behaviour</strong></p>
<p>If a consumer NACKs or REJECTs a message with the <code>:requeue?</code> flag set (default on NACK), or message processing throws an exception, the message will be dead-lettered. This means:</p>
<ol>
  <li>Publish the message to the backoff exchange, setting an “expiration”  value. The message will be added to the dead-letter queue.</li>
  <li>Once the timeout expires, the message will be published to the retry  exchange. Since a binding to this exchange was added to the original  consumer queue, the message will reappear there.</li>
</ol>
<p><strong>Caveat</strong></p>
<p>There is one caveat (also noted in the RabbitMQ documentation), consisting of expiry only happening at the head of the queue. This means that all messages in the dead letter queue will take at least the same time as the current head to be republished.</p>
<p>See: <a href="https://www.rabbitmq.com/ttl.html">https://www.rabbitmq.com/ttl.html</a></p></div></div><div class="src-link"><a href="https://github.com/xsc/kithara/blob/v0.1.0-SNAPSHOT/src/kithara/patterns/dead_letter_backoff.clj#L230">view source</a></div></div><div class="public anchor" id="var-with-durable-dead-letter-backoff"><h3>with-durable-dead-letter-backoff</h3><div class="usage"><code>(with-durable-dead-letter-backoff consumers &amp; [{:keys [backoff-exchange retry-exchange queue]}])</code></div><div class="doc"><div class="markdown"><p>See <a href="kithara.patterns.dead-letter-backoff.html#var-with-dead-letter-backoff">with-dead-letter-backoff</a>. Will create/expect durable, non-exclusive and non-auto-delete dead-letter queues/exchanges.</p>
<p>Note that this makes only sense if the original consumer queue has the same properties, since otherwise you’ll lose dead-lettered messages on retry.</p></div></div><div class="src-link"><a href="https://github.com/xsc/kithara/blob/v0.1.0-SNAPSHOT/src/kithara/patterns/dead_letter_backoff.clj#L321">view source</a></div></div></div></body></html>